crewjam/saml: Signature bypass via multiple Assertion elements

The crewjam/saml go library is vulnerable to an authentication bypass when processing SAML responses containing multiple Assertion elements.

// service_provider.go
func (sp *ServiceProvider) ParseXMLResponse(decodedResponseXML []byte, possibleRequestIDs []string) (*Assertion, error) {
        now := TimeNow()
        var err error
        retErr := &InvalidResponseError{
                Now:      now,
                Response: string(decodedResponseXML),
        }

        // ensure that the response XML is well formed before we parse it
        if err := xrv.Validate(bytes.NewReader(decodedResponseXML)); err != nil {
                retErr.PrivateErr = fmt.Errorf(\"invalid xml: %s\", err)
                return nil, retErr
        }

        // do some validation first before we decrypt
        resp := Response{}
        if err := xml.Unmarshal(decodedResponseXML, &resp); err != nil { (A)
                retErr.PrivateErr = fmt.Errorf(\"cannot unmarshal response: %s\", err)
                return nil, retErr
        }

        doc := etree.NewDocument()
        if err := doc.ReadFromBytes(decodedResponseXML); err != nil { (B)
                retErr.PrivateErr = err
                return nil, retErr
        }

        assertion, updatedResponse, err := sp.validateXMLResponse(&resp, doc.Root(), possibleRequestIDs, now, true) (C) 
        if err != nil {
                retErr.PrivateErr = err
                if updatedResponse != nil {
                        retErr.Response = *updatedResponse
                }
                return nil, retErr
        }

        return assertion, nil
}


The entry method ParseXMLResponse parses SAML responses twice: First using a call to xml.Unmarshal in (A), which returns a native Golang representation of the response. Second, using the etree interface in (B) which initializes an etree.Document object. The golang Response object and a reference to the etree root element are then passed into the validateXMLResponse method in (C):


func (sp *ServiceProvider) validateXMLResponse(resp *Response, responseEl *etree.Element, possibleRequestIDs []string, now time.Time, needSig bool) (*Assertion, *string, error) {
        [..]
        var assertion *Assertion
        if resp.EncryptedAssertion == nil {
                [..

                if err = sp.validateSigned(responseEl); err != nil && !(!needSig && err.Error() == \"either the Response or Assertion must be signed\") { (D)
                        return nil, updatedResponse, err
                }

                assertion = resp.Assertion (E)
        }

      [..]

        return assertion, updatedResponse, nil
}


Assuming we have a SAML response with no encrypted assertions, validateXMLResponse tries to validate embedded signatures using a call to validateSigned (D). If this succeeds the function returns the assertion stored as a member of the native Response object in (E).

validateSigned tries to verify signatures on both the Response itself or an embedded Assertion. As long as either one of them has a signature, the response is considered valid:
func (sp *ServiceProvider) validateSigned(responseEl *etree.Element) error {
        haveSignature := false

        // Some SAML responses have the signature on the Response object, and some on the Assertion
        // object, and some on both. We will require that at least one signature be present and that
        // all signatures be valid
        sigEl, err := findChild(responseEl, \"http://www.w3.org/2000/09/xmldsig#\", \"Signature\")
        if err != nil {
                return err
        }
        if sigEl != nil {
                if err = sp.validateSignature(responseEl); err != nil {
                        return fmt.Errorf(\"cannot validate signature on Response: %v\", err)
                }
                haveSignature = true
        }

        assertionEl, err := findChild(responseEl, \"urn:oasis:names:tc:SAML:2.0:assertion\", \"Assertion\") (F)
        if err != nil {
                return err
        }
        if assertionEl != nil {
                sigEl, err := findChild(assertionEl, \"http://www.w3.org/2000/09/xmldsig#\", \"Signature\") (G)
                if err != nil {
                        return err
                }
                if sigEl != nil {
                        if err = sp.validateSignature(assertionEl); err != nil { (H)
                                return fmt.Errorf(\"cannot validate signature on Response: %v\", err)
                        }
                        haveSignature = true
                }
        }

        if !haveSignature {
                return errors.New(\"either the Response or Assertion must be signed\")
        }
        return nil
}


Interestingly, the method only operates on the etree representation of the SAML response. The code in (F) iterates through all children of the Response element until an Assertion element is found. It then extracts its signature in (G) and validates it in (H). 

This would be acceptable if assertionEl from (H) always corresponds to the native Assertion object stored in resp.Assertion (E). However, this is not the case when a SAML response containing multiple Assertion elements is processed:

The golang Response type used for the native representation only stores a single Assertion (see the TODO in the last line). If xml.Unmarshal processes more than one Assertion during parsing it will only store the last element in the Response.Assertion attribute. 
type Response struct {
        [..]

        // TODO(ross): more than one Assertion is allowed
        Assertion *Assertion `xml:\"urn:oasis:names:tc:SAML:2.0:assertion Assertion\"`
}


In contrast, the call in (F) will always extract the first Assertion element in the Response.
An attacker with access to a single valid signed SAML assertion can exploit this behavior by preparing a malicious SAML response with the following layout:

<Response>
<Assertion id=valid><Signature>...</Signature>...</Assertion>
<Assertion id=malicious>...</Assertion>
</Response>


The first Assertion needs to be signed by the IdP, the second assertion can contain arbitrary information which will be returned to the application.

I've attached a git diff for the current version that demonstrates the issue through a new unit test.

Suggested Fix:
I think the code should enforce that a Response can only contain a single Assertion or EncryptedAssertion. Switching the Assertion and EncryptedAssertion members to a slices and enforcing len(.Assertion) + len(.EncryptedAssertion) == 1 should work.

The approach of having two different representations of the same response where one is verified but the other one is returned seems quite risky in general. 
Maybe it would make sense to replace the xml.Unmarshal call with a manual etree based version?

This bug is subject to a 90-day disclosure deadline. If a fix for this issue is made available to users before the end of the 90-day deadline, this bug report will become public 30 days after the fix was made available. Otherwise, this bug report will become public at the deadline. The scheduled deadline is 2023-01-05. For more details, see the Project Zero vulnerability disclosure policy: https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-policy.html








Related CVE Numbers: CVE-2022-41912.



Found by: fwilhelm@google.com

